## 3. JVM基础知识


首先看一个问题, 怎样才算入门?

- 掌握基本的JVM基础知识, 内存划分, 常用参数配置

- 会使用工具, 看懂日志，监控, 判断各种指标是否正常

- 会搜索问题，能大致确定是什么问题，搜索/咨询解决方案, 或者自己搞定


不入门就是"门外汉"，门外汉就是只知道这里有一个庞然大物，云里雾里，不了解里面有什么, 需要注意些什么。

只要工具用好了，获取到相关的状态信息，并能简单分析，那么JVM诊断这个技能就算是入门了，

本文从如何各类易于上手的工具作为切入点，讲解如何对JVM进行问题诊断， 通过监控和分析，判断是不是JVM层面的问题。

> 实际上，能熟练应用并理解 JVisulVM 及其报告的各种信息，JVM就算是入门了。



Java体系中有很多规范， 其中最基本的是 [`Java语言规范` 和 `Java虚拟机规范`](https://docs.oracle.com/javase/specs/index.html)

> 各个领域的神级人物，一般都通读和掌握相关规范。


### 3.1 JVM背景知识

JVM是Java程序的底层执行环境，主要用C++语言开发，如果想深入探索JVM，那么就需要掌握一定的C++语言知识，至少也应该看得懂C++代码。

JVM的操作对象是class文件，而不是java源码。

看起来很难的样子。 就像很多神书一样，讲JVM开篇就讲怎么编译JVM。讲JMM一来就引入CPU寄存器怎么同步。

当然，不需要很深的技术栈，也是可以排查JVM问题的。


> 题外话: 目前，最多的Java虚拟机实例位于Android设备中，绝大部分的Linux系统也运行在Android设备上。
>
> 在前些年，由于存储的限制，软件安装包的大小很受关注。Java安装包分为2种类型： JDK是完全版安装包， JRE是阉割版安装包。
>
> 如今Java语言的主要应用领域是企业环境，所以Oracle在JRE的基础上，增加一部分JDK内置的工具，组合成Server JRE 版，但实际上这增加了选择的复杂度，有点鸡肋。实际使用时直接安装JDK即可。


先来看看需要具备哪些基础知识，有相关基础的读者大致过一眼即可。


### 3.2 JVM内存结构

根据对JVM内存划分的理解，制作了几张逻辑概念图。大家可以参考一下。

先看看栈内存(Stack)的大体结构：

![栈内存](01_01_jvm_stack.jpg)

每启动一个线程，JVM就会在栈空间栈分配对应的 **线程栈**, 比如 1MB 的空间（`-Xss1m`）。

线程栈也叫做Java方法栈。 如果使用了JNI方法，则会分配一个单独的本地方法栈(Native Stack).


线程执行过程中，一般会有多个方法组成调用栈(Stack Trace), 比如A调用B，B调用C。。。每执行到一个方法，就会创建对应的 **栈帧**(Frame).

![栈帧](01_02_jvm_stack_frame.jpg)

栈帧只是一个逻辑上的概念，具体的大小，在一个方法编写完成后基本上就能确定。

比如返回值需要有一个空间存放吧，每个局部变量都需要对应的地址空间，此外还有操作数栈，以及方法指针(标识这个栈帧对应的是哪个类的哪个方法,指向常量池中的字符串常量）。


Java程序除了栈内存之外，最主要内存区域就是堆内存了。

![Java堆](01_03_jvm_heap.jpg)

堆内存是所有线程共用的内存空间，理论上大家都可以访问里面的内容。

但JVM的具体实现一般会有各种优化。

比如将逻辑上的Java堆,划分为堆(Heap)和非堆(Non-Heap)两个部分.  这种划分的依据在于，我们编写的Java代码，基本上只能使用Heap这部分空间，发生内存分配和回收的主要区域也在这部分，所以有一种说法，这里的Heap也叫GC管理的堆(GC Heap)。

GC理论中有一个重要的思想，叫做分代。 经过研究发现，程序中分配的对象，要么用过就扔，要么就能存活很久很久。

JVM将Heap内存分为年轻代（Young generation）和老年代（Old generation, 也叫 Tenured）两部分。

年轻代还划分为3个内存池，新生代(Eden space)和存活区(Survivor space), 存活区在大部分GC算法中有2个(S0, S1)，S0和S1总有一个是空的,但一般较小，也不浪费多少空间。

具体实现对新生代还有优化，那就是TLAB(Thread Local Allocation Buffer), 给每个线程先划定一小片空间，你创建的对象先在这里分配，满了再换。这能极大降低并发资源锁定的开销。


Non-Heap本质上还是Heap，只是一般不归GC管理，里面划分为3个内存池。

- Metaspace, 以前叫持久代(永久代, Permanent generation), Java8换了个名字叫 Metaspace.
  Java8将方法区移动到了Meta区里面，而方法又是class的一部分。。。和CCS交叉了?
- CCS, Compressed Class Space, 存放class信息的，和 Metaspace 有交叉。
- Code Cache, 存放 JIT 编译器编译后的本地机器代码。


JVM的内存结构大致如此。

还可以参考 [Metaspace解密](http://lovestblog.cn/blog/2016/10/29/metaspace/)
